// src/decoder.veryl

// support for
// ADD, ADDI, SUB, SLT, SLTI, AND, OR, LW, SW
//
// [31..26]     [5..0]              sub  op alu_src s_ext rf_we dm_we  r_src d_src
// -------------------------------- ---  -- ------- ----- ----- -----  ----- -----
// 00_1100 (0x0c)              ANDI  x   00    1      0     1     0      1     0
// 00_1101 (0x0d)              ORI   x   01    1      0     1     0      1     0
// 00_1000 (0x08)              ADDI  0   10    1      1     1     0      1     0
// 00_1010 (0x0a)              SLTI  1   11    1      1     1     0      1     0
// 10_0011 (0x23)              LW    0   10    1      1     1     0      1     1
// 10_0011 (0x2b)              SW    0   10    1      1     x     1      1     x

// 000000       10_0100 (0x24) AND   x   00    0      x     1     0      0     0
// 000000       10_0101 (0x25) OR    x   01    0      x     1     0      0     0
// 000000       10_0000 (0x20) ADD   0   10    0      x     1     0      0     0
// 000000       10_0010 (0x22) SUB   1   10    0      x     1     0      0     0
// 000000       10_1010 (0x2a) SLT   1   11    0      x     1     0      0     0

// sub AluSub
// 0 Additon
// 1 Subtraction

// op AluOp
// 00 AND
// 01 OR
// 10 Arith
// 11 Neg

// alu_src AluSource
// 0 reg b
// 1 imm

// s_ext immediate
// 0 zero extend
// 1 sign extend

// rf_we register file write enable
// 0 disable
// 1 enable

// dm_we data memory write enable
// 0 disable
// 1 enable

// r_src reg_destination
// 0 rt
// 1 rd

// d_src data to register file
// 0 alu
// 1 dm

module Decoder (
    i_opcode         : input  logic<6>,
    i_funct          : input  logic<6>,
    i_z              : input  logic   ,
    o_reg_destination: output logic   ,
    o_write_enable   : output logic   ,
    o_sign_extend    : output logic   ,
    o_alu_source     : output logic   ,
    o_alu_sub        : output logic   ,
    o_alu_op         : output logic<2>,
    o_dm_we          : output logic   ,
    o_rf_d_source    : output logic   ,
) {
    always_comb {

        case i_opcode {
            // I type instructions
            //          andi (0c)
            6'b00_1100: {
                            o_reg_destination = 0; // rt
                            o_write_enable    = 1;
                            o_sign_extend     = 0;
                            o_alu_source      = 1;
                            o_alu_sub         = 0;
                            o_alu_op          = 2'b00; // and
                            o_dm_we           = 0;
                            o_rf_d_source     = 0;
                        }
                        // ori (0d)
            6'b00_1101: {
                            o_reg_destination = 0; // rt
                            o_write_enable    = 1;
                            o_sign_extend     = 0;
                            o_alu_source      = 1;
                            o_alu_sub         = 0;
                            o_alu_op          = 2'b01; // or
                            o_dm_we           = 0;
                            o_rf_d_source     = 0;
                        }
                        // addi (08)
            6'b00_1000: {
                            o_reg_destination = 0; // rt
                            o_write_enable    = 1;
                            o_sign_extend     = 1;
                            o_alu_source      = 1;
                            o_alu_sub         = 0;
                            o_alu_op          = 2'b10; // arith
                            o_dm_we           = 0;
                            o_rf_d_source     = 0;
                        }
                        // slti (0a)
            6'b00_1010: {
                            o_reg_destination = 0; // rt
                            o_write_enable    = 1;
                            o_sign_extend     = 1;
                            o_alu_source      = 1;
                            o_alu_sub         = 1;
                            o_alu_op          = 2'b11; // slt
                            o_dm_we           = 0;
                            o_rf_d_source     = 0;
                        }
                        // lw (23)
            6'b10_0011: {
                            o_reg_destination = 0; // rt
                            o_write_enable    = 1;
                            o_sign_extend     = 1;
                            o_alu_source      = 1;
                            o_alu_sub         = 0;
                            o_alu_op          = 2'b10; // arith
                            o_dm_we           = 0;
                            o_rf_d_source     = 1;
                        }
                        // sw (2b)
            6'b10_1011: {
                            o_reg_destination = 0; // rt
                            o_write_enable    = 0; // no write to register file
                            o_sign_extend     = 1;
                            o_alu_source      = 1;
                            o_alu_sub         = 0;
                            o_alu_op          = 2'b10; // arith
                            o_dm_we           = 1;
                            o_rf_d_source     = 0; // don't care
                        }
                        // R-type
            6'b00_0000: {
                            o_reg_destination = 1;
                            o_write_enable    = 1;
                            o_alu_source      = 0;
                            o_sign_extend     = 0;
                            o_dm_we           = 0; // no write to data memory
                            o_rf_d_source     = 0; // alu result
                            o_alu_sub         = i_funct[1];
                            case i_funct {
                                // and
                                6'b10_0100: {
                                    o_alu_op = 2'b00;
                                }
                                // or
                                6'b10_0101: {
                                    o_alu_op = 2'b01;
                                }
                                // add
                                6'b10_0000: {
                                    o_alu_op = 2'b10;
                                }
                                // sub
                                6'b10_0010: {
                                    o_alu_op = 2'b10;
                                }
                                // slt
                                6'b10_1010: {
                                    o_alu_op = 2'b11;
                                }

                                default: {
                                 o_write_enable = 0;
                                 o_alu_source   = 0; // don't care
                                 o_alu_sub      = 0; // don't care
                                 o_alu_op       = 2'b00; // don't care
                             }
                            }
                        }

            default: {
                         o_write_enable    = 0;
                         o_reg_destination = 0; // don't care
                         o_sign_extend     = 0; // don't care
                         o_alu_source      = 0; // don't care
                         o_alu_sub         = 0; // don't care
                         o_alu_op          = 2'b00; // don't care
                         o_dm_we           = 0;
                         o_rf_d_source     = 0; // don't care
                     }
        }
    }
}

#[test(decoder)]
embed (inline) sv{{{
    module test;
        logic [5:0] opcode;
        logic [5:0] funct;
        logic z;
        logic reg_destination;
        logic write_enable;
        logic sign_extend;
        logic alu_source;
        logic alu_sub;
        logic [1:0] alu_op; 
        logic dm_we;
        logic rf_d_src;

        vips_Decoder decoder(
            opcode,
            funct,
            z,
            reg_destination,
            write_enable,
            sign_extend,
            alu_source,
            alu_sub,
            alu_op,
            dm_we,
            rf_d_src
        );

        initial begin
            // test I type
            // andi
            opcode = 6'b00_1100;
            #10;

            // ori
            opcode = 6'b00_1101;
            #10;

            // addi
            opcode = 6'b00_1000;
            #10;

            // slt 
            opcode = 6'b00_1010; 
            #10;

            // test R type
            opcode = 0;

            // and
            funct = 6'b10_0100;
            #10;

            // or
            funct = 6'b10_0101;
            #10;

            // add
            funct = 6'b10_0000;
            #10;

            // sub
            funct = 6'b10_0010;
            #10;
                                
            // slt
            funct = 6'b10_1010;
            #10;

            // nor 
            opcode = 6'b00_0000;
            funct = 6'b10_0111;
            #10;

            // lui 
            opcode = 6'b11_1111;
            #10;

            $finish;
        end
    endmodule
}}}
